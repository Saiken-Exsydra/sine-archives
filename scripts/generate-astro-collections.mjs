// scripts/generate-astro-collections.mjs
import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();

const SECTIONS_PATH = path.join(ROOT, "src", "sections.json");
const OUT_PATH = path.join(ROOT, "src", "content", "config.ts");
const CONTENT_ROOT = path.join(ROOT, "src", "content");


function fail(msg) {
  console.error(`\n‚ùå ${msg}\n`);
  process.exit(1);
}

function readSections() {
  if (!fs.existsSync(SECTIONS_PATH)) fail(`Missing file: ${SECTIONS_PATH}`);

  let raw;
  try {
    raw = fs.readFileSync(SECTIONS_PATH, "utf8");
  } catch (e) {
    fail(`Could not read ${SECTIONS_PATH}: ${e.message}`);
  }

  let data;
  try {
    data = JSON.parse(raw);
  } catch (e) {
    fail(`sections.json is not valid JSON: ${e.message}`);
  }

  if (!Array.isArray(data)) fail(`sections.json must be a JSON array (starts with [ ... ])`);

  // Minimal validation (no assumptions beyond what you showed)
  for (let i = 0; i < data.length; i++) {
    const s = data[i];
    if (!s || typeof s !== "object") fail(`sections[${i}] is not an object`);
    if (typeof s.key !== "string" || !s.key.trim()) fail(`sections[${i}].key must be a non-empty string`);
    if (typeof s.label !== "string") fail(`sections[${i}].label must be a string`);
    if (typeof s.typeDefault !== "string") fail(`sections[${i}].typeDefault must be a string`);
  }

  // Stable ordering (matches file order). Also guard against duplicate keys.
  const seen = new Set();
  for (const s of data) {
    if (seen.has(s.key)) fail(`Duplicate section key found in sections.json: "${s.key}"`);
    seen.add(s.key);
  }

  return data;
}

function ensureSectionFolders(sections) {
  for (const s of sections) {
    const dir = path.join(CONTENT_ROOT, s.key);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log(`üìÅ Created folder: src/content/${s.key}/`);
    }
  }
}


function generateConfigTs(sections) {
  const keys = sections.map((s) => s.key);

  // We intentionally keep the schema behavior the same as your current manual file
  // to avoid breaking existing content (type stays z.string()).
  const header = `// ‚ö†Ô∏è AUTO-GENERATED FILE ‚Äî DO NOT EDIT BY HAND
// Generated by: scripts/generate-astro-collections.mjs
// Source of truth: src/sections.json

import { defineCollection, z } from "astro:content";

const entrySchema = z.object({
  title: z.string(),
  type: z.string(),
  summary: z.string(),
  tags: z.array(z.string().min(1)).min(1),
  status: z.enum(["public", "private"]),
  created: z.preprocess(
    (v) => (v instanceof Date ? v.toISOString().slice(0, 10) : v),
    z.string()
  ),
  updated: z.preprocess(
    (v) => (v instanceof Date ? v.toISOString().slice(0, 10) : v),
    z.string()
  ),
  image: z.string().optional(),
});

`;

  const collectionLines = keys
    .map((key) => `const ${key} = defineCollection({ schema: entrySchema });`)
    .join("\n");

  const exportLines = `\n\nexport const collections = {\n  ${keys.join(",\n  ")}\n};\n`;

  return header + collectionLines + exportLines;
}

function writeIfChanged(outPath, content) {
  const existing = fs.existsSync(outPath) ? fs.readFileSync(outPath, "utf8") : null;
  if (existing === content) {
    console.log("‚úÖ src/content/config.ts is already up to date.");
    return;
  }

  fs.mkdirSync(path.dirname(outPath), { recursive: true });
  fs.writeFileSync(outPath, content, "utf8");
  console.log("‚úÖ Wrote src/content/config.ts");
}

const sections = readSections();
ensureSectionFolders(sections);
const ts = generateConfigTs(sections);
writeIfChanged(OUT_PATH, ts);
