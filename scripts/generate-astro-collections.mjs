// scripts/generate-astro-collections.mjs
import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();

const SECTIONS_PATH = path.join(ROOT, "src", "sections.json");
const CONTENT_ROOT = path.join(ROOT, "src", "content");
const OUT_PATH = path.join(CONTENT_ROOT, "config.ts");

function fail(msg) {
  console.error(`\n‚ùå ${msg}\n`);
  process.exit(1);
}

function readJson(filePath) {
  if (!fs.existsSync(filePath)) fail(`Missing file: ${filePath}`);

  try {
    const raw = fs.readFileSync(filePath, "utf8");
    return JSON.parse(raw);
  } catch (e) {
    fail(`Could not read/parse JSON at ${filePath}: ${e.message}`);
  }
}

function readSections() {
  const data = readJson(SECTIONS_PATH);

  if (!Array.isArray(data)) {
    fail(`src/sections.json must be a JSON array (it should start with [ and end with ])`);
  }

  // Minimal validation + duplicate guard
  const seen = new Set();
  for (let i = 0; i < data.length; i++) {
    const s = data[i];

    if (!s || typeof s !== "object") fail(`sections[${i}] is not an object`);

    if (typeof s.key !== "string" || !s.key.trim()) {
      fail(`sections[${i}].key must be a non-empty string`);
    }
    if (typeof s.label !== "string") {
      fail(`sections[${i}].label must be a string`);
    }
    if (typeof s.typeDefault !== "string") {
      fail(`sections[${i}].typeDefault must be a string`);
    }

    if (seen.has(s.key)) fail(`Duplicate section key found: "${s.key}"`);
    seen.add(s.key);
  }

  return data;
}

function ensureSectionFolders(sections) {
  for (const s of sections) {
    const dir = path.join(CONTENT_ROOT, s.key);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log(`üìÅ Created folder: src/content/${s.key}/`);
    }
  }
}

function generateConfigTs(sections) {
  const keys = sections.map((s) => s.key);

  // Keep schema behavior identical to your current manual config.ts
  const header = `// ‚ö†Ô∏è AUTO-GENERATED FILE ‚Äî DO NOT EDIT BY HAND
// Generated by: scripts/generate-astro-collections.mjs
// Source of truth: src/sections.json

import { defineCollection, z } from "astro:content";

const entrySchema = z.object({
  title: z.string(),
  type: z.string(),
  summary: z.string(),
  tags: z.array(z.string().min(1)).min(1),
  status: z.enum(["public", "private"]),
  created: z.preprocess(
    (v) => (v instanceof Date ? v.toISOString().slice(0, 10) : v),
    z.string()
  ),
  updated: z.preprocess(
    (v) => (v instanceof Date ? v.toISOString().slice(0, 10) : v),
    z.string()
  ),
  image: z.string().optional(),
});

`;

  // IMPORTANT:
  // We do NOT generate variables like "const test-section" (invalid JS).
  // We generate an object with quoted keys instead, which supports dashes safely.
  const collectionsObject =
    `export const collections = {\n` +
    keys
      .map((key) => `  ${JSON.stringify(key)}: defineCollection({ schema: entrySchema }),`)
      .join("\n") +
    `\n};\n`;

  return header + collectionsObject;
}

function writeIfChanged(filePath, content) {
  const existing = fs.existsSync(filePath) ? fs.readFileSync(filePath, "utf8") : null;

  if (existing === content) {
    console.log("‚úÖ src/content/config.ts is already up to date.");
    return;
  }

  fs.mkdirSync(path.dirname(filePath), { recursive: true });
  fs.writeFileSync(filePath, content, "utf8");
  console.log("‚úÖ Wrote src/content/config.ts");
}

// Run
const sections = readSections();
ensureSectionFolders(sections);
const ts = generateConfigTs(sections);
writeIfChanged(OUT_PATH, ts);
